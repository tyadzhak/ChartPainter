<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV to Line Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .input-section {
            margin-bottom: 30px;
        }
        input[type="file"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button.export-btn {
            background-color: #2196F3;
            margin-top: 15px;
            margin-left: 0;
        }
        button.export-btn:hover {
            background-color: #0b7dda;
        }
        .export-section {
            text-align: center;
            margin-top: 20px;
            display: none;
        }
        .export-section.show {
            display: block;
        }
        .chart-type-selector {
            display: none;
            text-align: center;
            margin: 20px 0;
            gap: 10px;
        }
        .chart-type-selector.show {
            display: flex;
            justify-content: center;
        }
        .chart-type-btn {
            background-color: #e0e0e0;
            color: #333;
            padding: 8px 16px;
            border: 2px solid #999;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .chart-type-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        .chart-type-btn:hover {
            background-color: #b0b0b0;
        }
        .chart-type-btn.active:hover {
            background-color: #45a049;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 30px;
            display: none;
        }
        .chart-container.show {
            display: block;
        }
        .error {
            color: #d32f2f;
            padding: 15px;
            background-color: #ffebee;
            border-radius: 4px;
            margin-top: 10px;
            display: none;
        }
        .error.show {
            display: block;
        }
        .info {
            color: #1976d2;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 14px;
        }
        .info code {
            background-color: #c8e6f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CSV to Line Chart Generator</h1>
        
        <div class="input-section">
            <input type="file" id="csvFile" accept=".csv" />
            <button onclick="generateChart()">Generate Chart</button>
            <br><br>
            <label for="chartTitle">Chart Title (optional):</label>
            <input type="text" id="chartTitle" placeholder="Enter chart title" style="padding: 10px; border: 2px solid #ddd; border-radius: 4px; width: 250px; margin-left: 10px;" />
        </div>
        
        <div class="error" id="error"></div>
        
        <div class="info">
            <strong>How to use:</strong> Upload a CSV file where the first column contains X-axis labels and subsequent columns contain data series to plot.
            <br><br>
            <strong>To customize colors:</strong> Add a row with <code>__Color__</code> as the first value, then add color names for each column.
            <br><strong>Available colors:</strong> red, pink, orange, yellow, green, teal, blue, purple, indigo, gray, black, white, lime, navy, maroon, olive, aqua, silver
            <br><strong>Or use hex codes:</strong> #FF6384, #36A2EB, etc.
            <br><br>
            <strong>To add markers (optional):</strong> Add a <code>Marker</code> column. Format: <code>DatasetName</code> or <code>DatasetName:TEXT</code>
            <br>Examples: <code>Sales</code>, <code>Revenue:PEAK</code>, <code>Expenses:ALERT</code>
        </div>
        
        <div class="chart-type-selector" id="chartTypeSelector">
            <button class="chart-type-btn active" onclick="switchChartType('line')">Line Chart</button>
            <button class="chart-type-btn" onclick="switchChartType('area')">Area Chart</button>
            <button class="chart-type-btn" onclick="switchChartType('bar')">Bar Chart</button>
        </div>

        <div class="chart-container" id="lineChartContainer">
            <canvas id="lineChart"></canvas>
        </div>

        <div class="chart-container" id="areaChartContainer" style="display: none;">
            <canvas id="areaChart"></canvas>
        </div>

        <div class="chart-container" id="barChartContainer" style="display: none;">
            <canvas id="barChart"></canvas>
        </div>

        <div class="export-section" id="exportSection">
            <button class="export-btn" onclick="exportChart()">Export as JPG</button>
        </div>
    </div>

    <script>
        let charts = {
            line: null,
            area: null,
            bar: null
        };
        let currentChartType = 'line';
        let currentChartData = null;
        let currentChartTitle = null;

        function generateChart() {
            const fileInput = document.getElementById('csvFile');
            const errorDiv = document.getElementById('error');
            const chartContainer = document.getElementById('chartContainer');
            
            // Clear previous error
            errorDiv.classList.remove('show');
            errorDiv.textContent = '';
            
            if (!fileInput.files.length) {
                showError('Please select a CSV file first');
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const data = parseCSV(csv);
                    
                    if (data.labels.length === 0) {
                        showError('CSV file appears to be empty');
                        return;
                    }
                    
                    if (data.datasets.length === 0) {
                        showError('No data columns found in CSV file');
                        return;
                    }

                    document.getElementById('lineChartContainer').classList.add('show');
                    document.getElementById('chartTypeSelector').classList.add('show');
                    document.getElementById('exportSection').classList.add('show');
                    const chartTitle = document.getElementById('chartTitle').value.trim() || 'Line Chart from CSV Data';
                    createAllCharts(data, chartTitle);
                } catch (error) {
                    showError('Error parsing CSV: ' + error.message);
                }
            };

            reader.onerror = function() {
                showError('Error reading file');
            };

            reader.readAsText(file);
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must contain at least 2 rows');
            }

            // Parse header row
            const headers = parseCSVLine(lines[0]);

            if (headers.length < 2) {
                throw new Error('CSV must contain at least 2 columns');
            }

            // Identify data columns and find marker column
            const dataColumnIndices = [];
            const markerColumnIndex = headers.indexOf('Marker');

            for (let i = 1; i < headers.length; i++) {
                const header = headers[i];
                if (header !== 'Marker' && !header.endsWith('_Color')) {
                    dataColumnIndices.push(i);
                }
            }

            // Extract colors if a __Color__ row exists
            let colorRow = null;
            let dataStartIndex = 1;

            if (lines.length > 1) {
                const firstDataRow = parseCSVLine(lines[1]);
                if (firstDataRow[0] === '__Color__') {
                    colorRow = firstDataRow;
                    dataStartIndex = 2;
                }
            }

            // First column is labels, rest are data series
            const labels = [];
            const datasets = [];

            // Initialize datasets for each data column
            dataColumnIndices.forEach((colIndex, idx) => {
                let color = getColor(idx);
                let bgColor = getColor(idx, 0.1);

                // Use custom color from __Color__ row if available
                if (colorRow && colorRow[colIndex]) {
                    const colorValue = colorRow[colIndex].trim();
                    if (colorValue) {
                        color = colorNameToHex(colorValue);
                        bgColor = hexToRgba(color, 0.1);
                    }
                }

                datasets.push({
                    label: headers[colIndex],
                    data: [],
                    markers: [],
                    borderColor: color,
                    backgroundColor: bgColor,
                    tension: 0.3,
                    fill: false
                });
            });

            // Parse data rows
            for (let i = dataStartIndex; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                const values = parseCSVLine(lines[i]);
                labels.push(values[0]);

                // Check if this row has a marker and determine which dataset gets it
                let markersByDataset = {}; // { datasetIndex: markerText }
                if (markerColumnIndex !== -1 && values[markerColumnIndex]) {
                    const markerValue = values[markerColumnIndex].trim();
                    if (markerValue) {
                        // Parse format: "DatasetName" or "DatasetName:TEXT"
                        const parts = markerValue.split(':');
                        const datasetName = parts[0].trim();
                        const markerText = parts[1] ? parts[1].trim() : '';

                        // Find the dataset index that matches this name
                        for (let idx = 0; idx < dataColumnIndices.length; idx++) {
                            if (headers[dataColumnIndices[idx]].toLowerCase() === datasetName.toLowerCase()) {
                                markersByDataset[idx] = markerText;
                                break;
                            }
                        }
                    }
                }

                // Add values to respective datasets
                dataColumnIndices.forEach((colIndex, idx) => {
                    const value = parseFloat(values[colIndex]);
                    datasets[idx].data.push(isNaN(value) ? null : value);
                    datasets[idx].markers.push(idx in markersByDataset ? markersByDataset[idx] : false);
                });
            }

            return { labels, datasets };
        }

        function colorNameToHex(colorName) {
            const colors = {
                red: '#FF6384',
                pink: '#FF69B4',
                orange: '#FFA500',
                yellow: '#FFD700',
                green: '#4CAF50',
                teal: '#4BC0C0',
                blue: '#36A2EB',
                purple: '#9966FF',
                indigo: '#4B0082',
                gray: '#C0C0C0',
                black: '#000000',
                white: '#FFFFFF',
                lime: '#00FF00',
                navy: '#000080',
                maroon: '#800000',
                olive: '#808000',
                aqua: '#00FFFF',
                silver: '#C0C0C0'
            };

            const lowerName = colorName.toLowerCase().trim();
            return colors[lowerName] || colorName; // Return as-is if not found (might be a hex code)
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let insideQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"') {
                    if (insideQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        insideQuotes = !insideQuotes;
                    }
                } else if (char === ',' && !insideQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        function getColor(index, alpha = 1) {
            const colors = [
                `rgba(255, 99, 132, ${alpha})`,
                `rgba(54, 162, 235, ${alpha})`,
                `rgba(75, 192, 192, ${alpha})`,
                `rgba(255, 206, 86, ${alpha})`,
                `rgba(153, 102, 255, ${alpha})`,
                `rgba(255, 159, 64, ${alpha})`,
                `rgba(199, 199, 199, ${alpha})`,
                `rgba(83, 102, 255, ${alpha})`
            ];
            return colors[index % colors.length];
        }

        function createAllCharts(data, chartTitle) {
            currentChartData = data;
            currentChartTitle = chartTitle;
            createLineChart(data, chartTitle);
            createAreaChart(data, chartTitle);
            createBarChart(data, chartTitle);
        }

        function switchChartType(type) {
            currentChartType = type;

            // Hide all chart containers
            document.getElementById('lineChartContainer').style.display = 'none';
            document.getElementById('areaChartContainer').style.display = 'none';
            document.getElementById('barChartContainer').style.display = 'none';

            // Show selected chart container
            document.getElementById(type + 'ChartContainer').style.display = 'block';

            // Update button styles
            document.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function createLineChart(data, chartTitle = 'Line Chart from CSV Data') {
            const ctx = document.getElementById('lineChart').getContext('2d');

            if (charts.line) {
                charts.line.destroy();
            }

            // Custom plugin to add labels and markers
            const lineLabelsPlugin = {
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);

                        // Draw labels in the middle
                        const middleIndex = Math.floor(meta.data.length / 2);
                        const middlePoint = meta.data[middleIndex];

                        if (middlePoint && dataset.label) {
                            const x = middlePoint.x;
                            const y = middlePoint.y - 15;

                            ctx.fillStyle = dataset.borderColor;
                            ctx.font = 'bold 12px Arial';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(dataset.label, x, y);
                        }

                        // Draw markers (black X) at marked points
                        if (dataset.markers) {
                            meta.data.forEach((point, pointIndex) => {
                                const marker = dataset.markers[pointIndex];
                                if (marker !== false && point) {
                                    const x = point.x;
                                    const y = point.y;
                                    const size = 6;

                                    ctx.strokeStyle = '#000000';
                                    ctx.lineWidth = 2;
                                    ctx.lineCap = 'round';

                                    // Draw first diagonal line (\)
                                    ctx.beginPath();
                                    ctx.moveTo(x - size, y - size);
                                    ctx.lineTo(x + size, y + size);
                                    ctx.stroke();

                                    // Draw second diagonal line (/)
                                    ctx.beginPath();
                                    ctx.moveTo(x + size, y - size);
                                    ctx.lineTo(x - size, y + size);
                                    ctx.stroke();

                                    // Draw text if marker has custom text (not 'Y')
                                    if (marker && marker !== '') {
                                        ctx.fillStyle = '#000000';
                                        ctx.font = '11px Arial';
                                        ctx.textBaseline = 'bottom';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(marker, x, y - 12);
                                    }
                                }
                            });
                        }
                    });
                }
            };

            charts.line = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Values'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Categories'
                            }
                        }
                    }
                },
                plugins: [lineLabelsPlugin]
            });
        }

        function createAreaChart(data, chartTitle = 'Area Chart from CSV Data') {
            const ctx = document.getElementById('areaChart').getContext('2d');

            if (charts.area) {
                charts.area.destroy();
            }

            // Create datasets for area chart (with fill)
            const areaDatasets = data.datasets.map(dataset => ({
                ...dataset,
                fill: true,
                backgroundColor: dataset.backgroundColor,
                borderColor: dataset.borderColor,
                tension: 0.3
            }));

            // Custom plugin to add labels and markers
            const areaLabelsPlugin = {
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);

                        // Draw labels in the middle
                        const middleIndex = Math.floor(meta.data.length / 2);
                        const middlePoint = meta.data[middleIndex];

                        if (middlePoint && dataset.label) {
                            const x = middlePoint.x;
                            const y = middlePoint.y - 15;

                            ctx.fillStyle = dataset.borderColor;
                            ctx.font = 'bold 12px Arial';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(dataset.label, x, y);
                        }

                        // Draw markers (black X) at marked points
                        if (dataset.markers) {
                            meta.data.forEach((point, pointIndex) => {
                                const marker = dataset.markers[pointIndex];
                                if (marker !== false && point) {
                                    const x = point.x;
                                    const y = point.y;
                                    const size = 6;

                                    ctx.strokeStyle = '#000000';
                                    ctx.lineWidth = 2;
                                    ctx.lineCap = 'round';

                                    ctx.beginPath();
                                    ctx.moveTo(x - size, y - size);
                                    ctx.lineTo(x + size, y + size);
                                    ctx.stroke();

                                    ctx.beginPath();
                                    ctx.moveTo(x + size, y - size);
                                    ctx.lineTo(x - size, y + size);
                                    ctx.stroke();

                                    if (marker && marker !== '') {
                                        ctx.fillStyle = '#000000';
                                        ctx.font = '11px Arial';
                                        ctx.textBaseline = 'bottom';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(marker, x, y - 12);
                                    }
                                }
                            });
                        }
                    });
                }
            };

            charts.area = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: areaDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Values'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Categories'
                            }
                        }
                    }
                },
                plugins: [areaLabelsPlugin]
            });
        }

        function createBarChart(data, chartTitle = 'Bar Chart from CSV Data') {
            const ctx = document.getElementById('barChart').getContext('2d');

            if (charts.bar) {
                charts.bar.destroy();
            }

            // Custom plugin to add markers for bar chart
            const barMarkersPlugin = {
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);

                        // Draw markers (black X) at marked points
                        if (dataset.markers) {
                            meta.data.forEach((element, pointIndex) => {
                                const marker = dataset.markers[pointIndex];
                                if (marker !== false && element) {
                                    const x = element.x;
                                    const y = element.y;
                                    const size = 6;

                                    ctx.strokeStyle = '#000000';
                                    ctx.lineWidth = 2;
                                    ctx.lineCap = 'round';

                                    ctx.beginPath();
                                    ctx.moveTo(x - size, y - size);
                                    ctx.lineTo(x + size, y + size);
                                    ctx.stroke();

                                    ctx.beginPath();
                                    ctx.moveTo(x + size, y - size);
                                    ctx.lineTo(x - size, y + size);
                                    ctx.stroke();

                                    if (marker && marker !== '') {
                                        ctx.fillStyle = '#000000';
                                        ctx.font = '11px Arial';
                                        ctx.textBaseline = 'bottom';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(marker, x, y - 12);
                                    }
                                }
                            });
                        }
                    });
                }
            };

            charts.bar = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'x',
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Values'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Categories'
                            }
                        }
                    }
                },
                plugins: [barMarkersPlugin]
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }

        function exportChart() {
            const chartContainerId = currentChartType + 'ChartContainer';
            const chartContainer = document.getElementById(chartContainerId);
            const chartTitle = document.getElementById('chartTitle').value.trim() || 'chart';
            // Sanitize filename (remove special characters)
            const sanitizedFilename = chartTitle.replace(/[^a-z0-9_\-]/gi, '_').substring(0, 50);

            html2canvas(chartContainer, {
                backgroundColor: '#ffffff',
                scale: 2,
                logging: false
            }).then(canvas => {
                // Convert canvas to JPG
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/jpeg', 0.95);
                link.download = sanitizedFilename + '.jpg';
                link.click();
            }).catch(err => {
                showError('Error exporting chart: ' + err.message);
            });
        }
    </script>
</body>
</html>