<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV to Line Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .input-section {
            margin-bottom: 30px;
        }
        input[type="file"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button.export-btn {
            background-color: #2196F3;
            margin-top: 15px;
            margin-left: 0;
        }
        button.export-btn:hover {
            background-color: #0b7dda;
        }
        .export-section {
            text-align: center;
            margin-top: 20px;
            display: none;
        }
        .export-section.show {
            display: block;
        }
        .chart-type-selector {
            display: none;
            text-align: center;
            margin: 20px 0;
            gap: 10px;
        }
        .chart-type-selector.show {
            display: flex;
            justify-content: center;
        }
        .chart-type-btn {
            background-color: #e0e0e0;
            color: #333;
            padding: 8px 16px;
            border: 2px solid #999;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .chart-type-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        .chart-type-btn:hover {
            background-color: #b0b0b0;
        }
        .chart-type-btn.active:hover {
            background-color: #45a049;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 30px;
            display: none;
        }
        .chart-container.show {
            display: block;
        }
        .error {
            color: #d32f2f;
            padding: 15px;
            background-color: #ffebee;
            border-radius: 4px;
            margin-top: 10px;
            display: none;
        }
        .error.show {
            display: block;
        }
        .info {
            color: #1976d2;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 14px;
        }
        .info code {
            background-color: #c8e6f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CSV to Line Chart Generator</h1>
        
        <div class="input-section">
            <input type="file" id="csvFile" accept=".csv" />
            <button onclick="generateChart()">Generate Chart</button>
            <br><br>
            <label for="chartTitle">Chart Title (optional):</label>
            <input type="text" id="chartTitle" placeholder="Enter chart title" style="padding: 10px; border: 2px solid #ddd; border-radius: 4px; width: 250px; margin-left: 10px;" />
        </div>
        
        <div class="error" id="error"></div>
        
        <div class="info">
            <strong>How to use:</strong> Upload a CSV file where the first column contains X-axis labels and subsequent columns contain data series to plot.
            <br><br>
            <strong>To customize colors:</strong> Add a row with <code>__Color__</code> as the first value, then add color names for each column.
            <br><strong>Available colors:</strong> red, pink, orange, yellow, green, teal, blue, purple, indigo, gray, black, white, lime, navy, maroon, olive, aqua, silver
            <br><strong>Or use hex codes:</strong> #FF6384, #36A2EB, etc.
            <br><br>
            <strong>To add markers (optional):</strong> Add a <code>Marker</code> column. Format: <code>DatasetName</code> or <code>DatasetName:TEXT</code>
            <br>Examples: <code>Sales</code>, <code>Revenue:PEAK</code>, <code>Expenses:ALERT</code>
        </div>
        
        <div class="chart-type-selector" id="chartTypeSelector">
            <button class="chart-type-btn active" onclick="switchChartType('line')">Line Chart</button>
            <button class="chart-type-btn" onclick="switchChartType('area')">Area Chart</button>
            <button class="chart-type-btn" onclick="switchChartType('bar')">Bar Chart</button>
        </div>

        <div id="axisControlsSection" style="display: none; text-align: center; margin: 15px 0; gap: 15px; flex-wrap: wrap; justify-content: center;">
            <div>
                <label for="xAxisName">X-Axis Name:</label>
                <input type="text" id="xAxisName" placeholder="Categories" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; width: 120px;" />
            </div>
            <div>
                <label for="yAxisName">Y-Axis Name:</label>
                <input type="text" id="yAxisName" placeholder="Values" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; width: 120px;" />
            </div>
            <div>
                <label for="xAxisStep">X-Axis Step:</label>
                <input type="number" id="xAxisStep" placeholder="Auto" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; width: 100px;" />
            </div>
            <div>
                <label for="yAxisStep">Y-Axis Step:</label>
                <input type="number" id="yAxisStep" placeholder="Auto" style="padding: 8px; border: 2px solid #ddd; border-radius: 4px; width: 100px;" />
            </div>
            <button onclick="updateAxisSettings()" style="background-color: #2196F3; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">Apply</button>
        </div>

        <div class="chart-container" id="lineChartContainer">
            <canvas id="lineChart"></canvas>
        </div>

        <div class="chart-container" id="areaChartContainer" style="display: none;">
            <canvas id="areaChart"></canvas>
        </div>

        <div class="chart-container" id="barChartContainer" style="display: none;">
            <canvas id="barChart"></canvas>
        </div>

        <div class="export-section" id="exportSection">
            <button class="export-btn" onclick="exportChart()">Export as JPG</button>
        </div>
    </div>

    <script>
        let charts = {
            line: null,
            area: null,
            bar: null
        };
        let currentChartType = 'line';
        let currentChartData = null;
        let currentChartTitle = null;

        function generateChart() {
            const fileInput = document.getElementById('csvFile');
            const errorDiv = document.getElementById('error');
            const chartContainer = document.getElementById('chartContainer');
            
            // Clear previous error
            errorDiv.classList.remove('show');
            errorDiv.textContent = '';
            
            if (!fileInput.files.length) {
                showError('Please select a CSV file first');
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const data = parseCSV(csv);
                    
                    if (data.labels.length === 0) {
                        showError('CSV file appears to be empty');
                        return;
                    }
                    
                    if (data.datasets.length === 0) {
                        showError('No data columns found in CSV file');
                        return;
                    }

                    document.getElementById('lineChartContainer').classList.add('show');
                    document.getElementById('chartTypeSelector').classList.add('show');
                    document.getElementById('axisControlsSection').style.display = 'block';
                    document.getElementById('exportSection').classList.add('show');
                    const chartTitle = document.getElementById('chartTitle').value.trim() || 'Line Chart from CSV Data';
                    createAllCharts(data, chartTitle);
                } catch (error) {
                    showError('Error parsing CSV: ' + error.message);
                }
            };

            reader.onerror = function() {
                showError('Error reading file');
            };

            reader.readAsText(file);
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must contain at least 2 rows');
            }

            // Detect format: check if first line has ";;;;" (multi-test format)
            if (lines[0].includes(';;;;')) {
                return parseMultiTestFormat(lines);
            } else {
                return parseSingleTestFormat(lines);
            }
        }

        function parseMultiTestFormat(lines) {
            // Auto-detect where test names, headers, and data are
            // Test names row: has test names separated by ;;;;
            // Header row: contains column names like "Load,Value"
            // Data rows: contain numeric values

            let testNamesRow = -1;
            let headerRow = -1;
            let dataStartRow = -1;

            // Find header row (contains "," like "Load,Value")
            for (let i = 0; i < Math.min(lines.length, 10); i++) {
                if (lines[i].includes(',')) {
                    headerRow = i;
                    break;
                }
            }

            if (headerRow === -1) {
                throw new Error('Could not find header row with column definitions (should contain comma)');
            }

            // Find test names row (should be before header row, contains any non-empty cells)
            for (let i = headerRow - 1; i >= 0; i--) {
                const cells = lines[i].split(';');
                // Check if row has any non-empty cells (test names can be anything: letters, numbers, hyphens, etc.)
                const hasContent = cells.some(cell => cell.trim() !== '');

                if (hasContent) {
                    testNamesRow = i;
                    break;
                }
            }

            if (testNamesRow === -1) {
                throw new Error('Could not find test names row. Expected a row with test names before the header row.');
            }

            // Data starts after header row
            dataStartRow = headerRow + 1;

            // Parse test names (get non-empty cells)
            const testNamesCells = lines[testNamesRow].split(';');
            const testNames = [];

            testNamesCells.forEach((name) => {
                if (name.trim() !== '') {
                    testNames.push(name.trim());
                }
            });

            if (testNames.length === 0) {
                throw new Error('No test names found in row');
            }

            // Parse header row to get axis names for each test
            const headerCells = lines[headerRow].split(';');
            const headers = headerCells.filter(h => h.trim() !== ''); // Get non-empty headers
            const datasets = [];

            // Create datasets: assume headers and test names correspond in order
            testNames.forEach((testName, testIdx) => {
                const headerStr = headers[testIdx] || '';
                const axisNames = headerStr.split(',').map(h => h.trim()).filter(h => h);

                axisNames.forEach((axisName) => {
                    const datasetLabel = `${testName} ${axisName}`;
                    datasets.push({
                        label: datasetLabel,
                        data: [],
                        markers: [],
                        borderColor: getColor(datasets.length),
                        backgroundColor: getColor(datasets.length, 0.1),
                        tension: 0.3,
                        fill: false,
                        testIdx: testIdx
                    });
                });
            });

            // Parse data rows
            const labels = [];
            let rowCount = 0;
            for (let i = dataStartRow; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                const cells = lines[i].split(';');

                // Get non-empty data cells (matching how we parsed headers)
                const dataCells = cells.filter((_, idx) => cells[idx].trim() !== '');

                // Use the first value as label
                const firstCellData = dataCells[0] || '';
                if (firstCellData) {
                    const labelValue = firstCellData.includes(',') ? firstCellData.split(',')[0] : firstCellData;
                    labels.push(labelValue);
                } else {
                    labels.push(`Point ${rowCount}`);
                }
                rowCount++;

                // Add data to datasets
                let datasetIdx = 0;
                testNames.forEach((testName, testIdx) => {
                    const cellData = dataCells[testIdx] || '';

                    if (cellData) {
                        const values = cellData.split(',').map(v => parseFloat(v.trim()));
                        values.forEach((val) => {
                            if (!isNaN(val) && datasetIdx < datasets.length) {
                                datasets[datasetIdx].data.push(val);
                                datasets[datasetIdx].markers.push(false);
                                datasetIdx++;
                            }
                        });
                    } else {
                        // If no data, skip datasets for this test
                        const headerStr = headers[testIdx] || '';
                        const axisCount = headerStr.split(',').filter(h => h.trim()).length;
                        datasetIdx += axisCount;
                    }
                });
            }

            return { labels, datasets };
        }

        function parseSingleTestFormat(lines) {
            // Original format: single test with headers, colors, markers

            // Parse header row
            const headers = parseCSVLine(lines[0]);

            if (headers.length < 2) {
                throw new Error('CSV must contain at least 2 columns');
            }

            // Identify data columns and find marker column
            const dataColumnIndices = [];
            const markerColumnIndex = headers.indexOf('Marker');

            for (let i = 1; i < headers.length; i++) {
                const header = headers[i];
                if (header !== 'Marker' && !header.endsWith('_Color')) {
                    dataColumnIndices.push(i);
                }
            }

            // Extract colors if a __Color__ row exists
            let colorRow = null;
            let dataStartIndex = 1;

            if (lines.length > 1) {
                const firstDataRow = parseCSVLine(lines[1]);
                if (firstDataRow[0] === '__Color__') {
                    colorRow = firstDataRow;
                    dataStartIndex = 2;
                }
            }

            // First column is labels, rest are data series
            const labels = [];
            const datasets = [];

            // Initialize datasets for each data column
            dataColumnIndices.forEach((colIndex, idx) => {
                let color = getColor(idx);
                let bgColor = getColor(idx, 0.1);

                // Use custom color from __Color__ row if available
                if (colorRow && colorRow[colIndex]) {
                    const colorValue = colorRow[colIndex].trim();
                    if (colorValue) {
                        color = colorNameToHex(colorValue);
                        bgColor = hexToRgba(color, 0.1);
                    }
                }

                datasets.push({
                    label: headers[colIndex],
                    data: [],
                    markers: [],
                    borderColor: color,
                    backgroundColor: bgColor,
                    tension: 0.3,
                    fill: false
                });
            });

            // Parse data rows
            for (let i = dataStartIndex; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                const values = parseCSVLine(lines[i]);
                labels.push(values[0]);

                // Check if this row has a marker and determine which dataset gets it
                let markersByDataset = {}; // { datasetIndex: markerText }
                if (markerColumnIndex !== -1 && values[markerColumnIndex]) {
                    const markerValue = values[markerColumnIndex].trim();
                    if (markerValue) {
                        // Parse format: "DatasetName" or "DatasetName:TEXT"
                        const parts = markerValue.split(':');
                        const datasetName = parts[0].trim();
                        const markerText = parts[1] ? parts[1].trim() : '';

                        // Find the dataset index that matches this name
                        for (let idx = 0; idx < dataColumnIndices.length; idx++) {
                            if (headers[dataColumnIndices[idx]].toLowerCase() === datasetName.toLowerCase()) {
                                markersByDataset[idx] = markerText;
                                break;
                            }
                        }
                    }
                }

                // Add values to respective datasets
                dataColumnIndices.forEach((colIndex, idx) => {
                    const value = parseFloat(values[colIndex]);
                    datasets[idx].data.push(isNaN(value) ? null : value);
                    datasets[idx].markers.push(idx in markersByDataset ? markersByDataset[idx] : false);
                });
            }

            return { labels, datasets };
        }

        function colorNameToHex(colorName) {
            const colors = {
                red: '#FF6384',
                pink: '#FF69B4',
                orange: '#FFA500',
                yellow: '#FFD700',
                green: '#4CAF50',
                teal: '#4BC0C0',
                blue: '#36A2EB',
                purple: '#9966FF',
                indigo: '#4B0082',
                gray: '#C0C0C0',
                black: '#000000',
                white: '#FFFFFF',
                lime: '#00FF00',
                navy: '#000080',
                maroon: '#800000',
                olive: '#808000',
                aqua: '#00FFFF',
                silver: '#C0C0C0'
            };

            const lowerName = colorName.toLowerCase().trim();
            return colors[lowerName] || colorName; // Return as-is if not found (might be a hex code)
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let insideQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"') {
                    if (insideQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        insideQuotes = !insideQuotes;
                    }
                } else if (char === ',' && !insideQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        function getColor(index, alpha = 1) {
            const colors = [
                `rgba(255, 99, 132, ${alpha})`,
                `rgba(54, 162, 235, ${alpha})`,
                `rgba(75, 192, 192, ${alpha})`,
                `rgba(255, 206, 86, ${alpha})`,
                `rgba(153, 102, 255, ${alpha})`,
                `rgba(255, 159, 64, ${alpha})`,
                `rgba(199, 199, 199, ${alpha})`,
                `rgba(83, 102, 255, ${alpha})`
            ];
            return colors[index % colors.length];
        }

        function createAllCharts(data, chartTitle) {
            currentChartData = data;
            currentChartTitle = chartTitle;
            createLineChart(data, chartTitle);
            createAreaChart(data, chartTitle);
            createBarChart(data, chartTitle);
        }

        function switchChartType(type) {
            currentChartType = type;

            // Hide all chart containers
            document.getElementById('lineChartContainer').style.display = 'none';
            document.getElementById('areaChartContainer').style.display = 'none';
            document.getElementById('barChartContainer').style.display = 'none';

            // Show selected chart container
            document.getElementById(type + 'ChartContainer').style.display = 'block';

            // Update button styles
            document.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function createLineChart(data, chartTitle = 'Line Chart from CSV Data') {
            const ctx = document.getElementById('lineChart').getContext('2d');

            if (charts.line) {
                charts.line.destroy();
            }

            // Custom plugin to add labels and markers
            const lineLabelsPlugin = {
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);

                        // Draw labels in the middle
                        const middleIndex = Math.floor(meta.data.length / 2);
                        const middlePoint = meta.data[middleIndex];

                        if (middlePoint && dataset.label) {
                            const x = middlePoint.x;
                            const y = middlePoint.y - 15;

                            ctx.fillStyle = dataset.borderColor;
                            ctx.font = 'bold 12px Arial';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(dataset.label, x, y);
                        }

                        // Draw markers at marked points (colored by dataset)
                        if (dataset.markers) {
                            meta.data.forEach((point, pointIndex) => {
                                const marker = dataset.markers[pointIndex];
                                if (marker !== false && point) {
                                    const x = point.x;
                                    const y = point.y;
                                    const size = 6;

                                    ctx.strokeStyle = dataset.borderColor;
                                    ctx.lineWidth = 2;
                                    ctx.lineCap = 'round';

                                    // Draw first diagonal line (\)
                                    ctx.beginPath();
                                    ctx.moveTo(x - size, y - size);
                                    ctx.lineTo(x + size, y + size);
                                    ctx.stroke();

                                    // Draw second diagonal line (/)
                                    ctx.beginPath();
                                    ctx.moveTo(x + size, y - size);
                                    ctx.lineTo(x - size, y + size);
                                    ctx.stroke();

                                    // Draw text if marker has custom text (not 'Y')
                                    if (marker && marker !== '') {
                                        ctx.fillStyle = dataset.borderColor;
                                        ctx.font = '11px Arial';
                                        ctx.textBaseline = 'bottom';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(marker, x, y - 12);
                                    }
                                }
                            });
                        }
                    });
                }
            };

            charts.line = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Values'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Categories'
                            }
                        }
                    }
                },
                plugins: [lineLabelsPlugin]
            });
        }

        function createAreaChart(data, chartTitle = 'Area Chart from CSV Data') {
            const ctx = document.getElementById('areaChart').getContext('2d');

            if (charts.area) {
                charts.area.destroy();
            }

            // Create datasets for area chart (with fill)
            const areaDatasets = data.datasets.map(dataset => ({
                ...dataset,
                fill: true,
                backgroundColor: dataset.backgroundColor,
                borderColor: dataset.borderColor,
                tension: 0.3
            }));

            // Custom plugin to add labels and markers
            const areaLabelsPlugin = {
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);

                        // Draw labels in the middle
                        const middleIndex = Math.floor(meta.data.length / 2);
                        const middlePoint = meta.data[middleIndex];

                        if (middlePoint && dataset.label) {
                            const x = middlePoint.x;
                            const y = middlePoint.y - 15;

                            ctx.fillStyle = dataset.borderColor;
                            ctx.font = 'bold 12px Arial';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(dataset.label, x, y);
                        }

                        // Draw markers at marked points (colored by dataset)
                        if (dataset.markers) {
                            meta.data.forEach((point, pointIndex) => {
                                const marker = dataset.markers[pointIndex];
                                if (marker !== false && point) {
                                    const x = point.x;
                                    const y = point.y;
                                    const size = 6;

                                    ctx.strokeStyle = dataset.borderColor;
                                    ctx.lineWidth = 2;
                                    ctx.lineCap = 'round';

                                    ctx.beginPath();
                                    ctx.moveTo(x - size, y - size);
                                    ctx.lineTo(x + size, y + size);
                                    ctx.stroke();

                                    ctx.beginPath();
                                    ctx.moveTo(x + size, y - size);
                                    ctx.lineTo(x - size, y + size);
                                    ctx.stroke();

                                    if (marker && marker !== '') {
                                        ctx.fillStyle = dataset.borderColor;
                                        ctx.font = '11px Arial';
                                        ctx.textBaseline = 'bottom';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(marker, x, y - 12);
                                    }
                                }
                            });
                        }
                    });
                }
            };

            charts.area = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: areaDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Values'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Categories'
                            }
                        }
                    }
                },
                plugins: [areaLabelsPlugin]
            });
        }

        function createBarChart(data, chartTitle = 'Bar Chart from CSV Data') {
            const ctx = document.getElementById('barChart').getContext('2d');

            if (charts.bar) {
                charts.bar.destroy();
            }

            // Custom plugin to add markers for bar chart
            const barMarkersPlugin = {
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);

                        // Draw markers at marked points (colored by dataset)
                        if (dataset.markers) {
                            meta.data.forEach((element, pointIndex) => {
                                const marker = dataset.markers[pointIndex];
                                if (marker !== false && element) {
                                    const x = element.x;
                                    const y = element.y;
                                    const size = 6;

                                    ctx.strokeStyle = dataset.borderColor;
                                    ctx.lineWidth = 2;
                                    ctx.lineCap = 'round';

                                    ctx.beginPath();
                                    ctx.moveTo(x - size, y - size);
                                    ctx.lineTo(x + size, y + size);
                                    ctx.stroke();

                                    ctx.beginPath();
                                    ctx.moveTo(x + size, y - size);
                                    ctx.lineTo(x - size, y + size);
                                    ctx.stroke();

                                    if (marker && marker !== '') {
                                        ctx.fillStyle = dataset.borderColor;
                                        ctx.font = '11px Arial';
                                        ctx.textBaseline = 'bottom';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(marker, x, y - 12);
                                    }
                                }
                            });
                        }
                    });
                }
            };

            charts.bar = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'x',
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Values'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Categories'
                            }
                        }
                    }
                },
                plugins: [barMarkersPlugin]
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }

        function exportChart() {
            const chartContainerId = currentChartType + 'ChartContainer';
            const chartContainer = document.getElementById(chartContainerId);
            const chartTitle = document.getElementById('chartTitle').value.trim() || 'chart';
            // Sanitize filename (remove special characters)
            const sanitizedFilename = chartTitle.replace(/[^a-z0-9_\-]/gi, '_').substring(0, 50);

            html2canvas(chartContainer, {
                backgroundColor: '#ffffff',
                scale: 2,
                logging: false
            }).then(canvas => {
                // Convert canvas to JPG
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/jpeg', 0.95);
                link.download = sanitizedFilename + '.jpg';
                link.click();
            }).catch(err => {
                showError('Error exporting chart: ' + err.message);
            });
        }

        function updateAxisSettings() {
            const xAxisName = document.getElementById('xAxisName').value || 'Categories';
            const yAxisName = document.getElementById('yAxisName').value || 'Values';
            const xStep = document.getElementById('xAxisStep').value;
            const yStep = document.getElementById('yAxisStep').value;

            // Convert to numbers or null if empty
            const xStepValue = xStep ? parseInt(xStep) : null;
            const yStepValue = yStep ? parseFloat(yStep) : null;

            // Update all three charts
            [charts.line, charts.area, charts.bar].forEach(chart => {
                if (chart) {
                    // Update Y-axis settings
                    if (chart.options.scales.y) {
                        // Update axis name
                        if (!chart.options.scales.y.title) {
                            chart.options.scales.y.title = {};
                        }
                        chart.options.scales.y.title.text = yAxisName;

                        // Update Y-axis step
                        if (yStepValue) {
                            if (!chart.options.scales.y.ticks) {
                                chart.options.scales.y.ticks = {};
                            }
                            chart.options.scales.y.ticks.stepSize = yStepValue;
                        } else {
                            if (chart.options.scales.y.ticks) {
                                delete chart.options.scales.y.ticks.stepSize;
                            }
                        }
                    }

                    // Update X-axis settings
                    if (chart.options.scales.x) {
                        // Update axis name
                        if (!chart.options.scales.x.title) {
                            chart.options.scales.x.title = {};
                        }
                        chart.options.scales.x.title.text = xAxisName;

                        // Update X-axis step
                        if (xStepValue && xStepValue > 0) {
                            if (!chart.options.scales.x.ticks) {
                                chart.options.scales.x.ticks = {};
                            }
                            chart.options.scales.x.ticks.callback = function(value, index) {
                                return index % xStepValue === 0 ? this.getLabelForValue(value) : '';
                            };
                        } else {
                            if (chart.options.scales.x.ticks) {
                                delete chart.options.scales.x.ticks.callback;
                            }
                        }
                    }

                    chart.update();
                }
            });
        }
    </script>
</body>
</html>